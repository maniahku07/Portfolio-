{"ast":null,"code":"import { invariant } from '../../utils/errors.mjs';\nimport { setValues } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(function (value) {\n    return value.stop();\n  });\n}\n/**\n * @public\n */\n\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function start(definition, transitionOverride) {\n      invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      var animations = [];\n      subscribers.forEach(function (visualElement) {\n        animations.push(animateVisualElement(visualElement, definition, {\n          transitionOverride: transitionOverride\n        }));\n      });\n      return Promise.all(animations);\n    },\n    set: function set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function stop() {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function mount() {\n      hasMounted = true;\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\nexport { animationControls };","map":{"version":3,"names":["invariant","setValues","animateVisualElement","stopAnimation","visualElement","values","forEach","value","stop","animationControls","hasMounted","subscribers","Set","controls","subscribe","add","delete","start","definition","transitionOverride","animations","push","Promise","all","set","mount"],"sources":["C:/Users/Manish/Desktop/Portfolio-Website-main/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs"],"sourcesContent":["import { invariant } from '../../utils/errors.mjs';\nimport { setValues } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls };\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,wBAA1B;AACA,SAASC,SAAT,QAA0B,gCAA1B;AACA,SAASC,oBAAT,QAAqC,kCAArC;;AAEA,SAASC,aAAT,CAAuBC,aAAvB,EAAsC;EAClCA,aAAa,CAACC,MAAd,CAAqBC,OAArB,CAA6B,UAACC,KAAD;IAAA,OAAWA,KAAK,CAACC,IAAN,EAAX;EAAA,CAA7B;AACH;AACD;AACA;AACA;;;AACA,SAASC,iBAAT,GAA6B;EACzB;AACJ;AACA;EACI,IAAIC,UAAU,GAAG,KAAjB;EACA;AACJ;AACA;;EACI,IAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;EACA,IAAMC,QAAQ,GAAG;IACbC,SADa,qBACHV,aADG,EACY;MACrBO,WAAW,CAACI,GAAZ,CAAgBX,aAAhB;MACA,OAAO;QAAA,OAAM,KAAKO,WAAW,CAACK,MAAZ,CAAmBZ,aAAnB,CAAX;MAAA,CAAP;IACH,CAJY;IAKba,KALa,iBAKPC,UALO,EAKKC,kBALL,EAKyB;MAClCnB,SAAS,CAACU,UAAD,EAAa,iHAAb,CAAT;MACA,IAAMU,UAAU,GAAG,EAAnB;MACAT,WAAW,CAACL,OAAZ,CAAoB,UAACF,aAAD,EAAmB;QACnCgB,UAAU,CAACC,IAAX,CAAgBnB,oBAAoB,CAACE,aAAD,EAAgBc,UAAhB,EAA4B;UAC5DC,kBAAkB,EAAlBA;QAD4D,CAA5B,CAApC;MAGH,CAJD;MAKA,OAAOG,OAAO,CAACC,GAAR,CAAYH,UAAZ,CAAP;IACH,CAdY;IAebI,GAfa,eAeTN,UAfS,EAeG;MACZlB,SAAS,CAACU,UAAD,EAAa,+GAAb,CAAT;MACA,OAAOC,WAAW,CAACL,OAAZ,CAAoB,UAACF,aAAD,EAAmB;QAC1CH,SAAS,CAACG,aAAD,EAAgBc,UAAhB,CAAT;MACH,CAFM,CAAP;IAGH,CApBY;IAqBbV,IArBa,kBAqBN;MACHG,WAAW,CAACL,OAAZ,CAAoB,UAACF,aAAD,EAAmB;QACnCD,aAAa,CAACC,aAAD,CAAb;MACH,CAFD;IAGH,CAzBY;IA0BbqB,KA1Ba,mBA0BL;MACJf,UAAU,GAAG,IAAb;MACA,OAAO,YAAM;QACTA,UAAU,GAAG,KAAb;QACAG,QAAQ,CAACL,IAAT;MACH,CAHD;IAIH;EAhCY,CAAjB;EAkCA,OAAOK,QAAP;AACH;;AAED,SAASJ,iBAAT"},"metadata":{},"sourceType":"module"}